//
//    template<class K>
//    std::string Elf::getSectionName(K *Tsection) {
//        if (is64()) {
//            Elf64_Shdr *section = (Elf64_Shdr *) Tsection;
//            auto *header = (Elf64_Ehdr *) &_data[0];
//            uint64_t off = (((Elf64_Shdr *) &_data[header->e_shoff]))[header->e_shstrndx].sh_offset;
//            char *data = reinterpret_cast<char *>(&_data[off]);
//            std::string sectionName(data + section->sh_name);
//            return sectionName;
//        }
//        return "";
//    }
//
//    /**
//     * Returns the corresponding section by the given name
//     * @tparam  K the type of the section (Elf64_Ehdr, or Elf32_Ehdr)
//     * @param   name The name of the section
//     * @return  null on failure
//     *          the section on success
//     */
//    template<class K>
//    K *Elf::getSectionByName(const std::string &name) {
//        if (is64()) {
//            auto *header = (Elf64_Ehdr *) &_data[0];
//            //shdrs[shstrtabIndex].sh_offset
//            for (int k = 0; k < header->e_shnum; k++) {
//                auto shdr = &((Elf64_Shdr *) &_data[header->e_shoff])[k];
//                uint64_t off = (((Elf64_Shdr *) &_data[header->e_shoff]))[header->e_shstrndx].sh_offset;
//                char *data = reinterpret_cast<char *>(&_data[off]);
//                std::string sectionName(data + shdr->sh_name);
//                //log("Found section <%s> off:<%lx> info<%lx> addr<%lx>", sectionName.c_str(),
//                //    shdr->sh_offset, shdr->sh_info, shdr->sh_addr);
//                //log("shdr %d %p %d %s", off, data, shdr->sh_name, sectionName.c_str());
//                if (sectionName == name) {
//                    //Elf64_Dyn *dynamic = reinterpret_cast<Elf64_Dyn *>(&_data[shdr.sh_offset]);
//
//                    return (K *) shdr;
//                }
//            }
//        } else {
//            auto *header = (Elf32_Ehdr *) &_data[0];
//            //shdrs[shstrtabIndex].sh_offset
//            for (int k = 0; k < header->e_shnum; k++) {
//                auto shdr = &((Elf32_Shdr *) &_data[header->e_shoff])[k];
//                int off = (((Elf32_Shdr *) &_data[header->e_shoff]))[header->e_shstrndx].sh_offset;
//                char *data = reinterpret_cast<char *>(&_data[off]);
//                std::string sectionName(data + shdr->sh_name);
//
//                //log("Found section <%s> off:<%lx> info<%lx> addr<%lx>", sectionName.c_str(),
//                //    shdr->sh_offset, shdr->sh_info, shdr->sh_addr);
//                //log("shdr %d %p %d %s", off, data, shdr->sh_name, sectionName.c_str());
//                if (sectionName == name) {
//                    //Elf64_Dyn *dynamic = reinterpret_cast<Elf64_Dyn *>(&_data[shdr.sh_offset]);
//
//                    return (K *) shdr;
//                }
//            }
//        }
//
//        return nullptr;
//    }
//
//    /**
// * Returns the corresponding section by the given name
// * @tparam  K the type of the section (Elf64_Ehdr, or Elf32_Ehdr)
// * @param   name The name of the section
// * @return  null on failure
// *          the section on success
// */
//    template<class K>
//    K *Elf::getSectionById(const int id) {
//        if (is64()) {
//            auto *header = (Elf64_Ehdr *) &_data[0];
//
//            if (id > header->e_shnum) {
//                log("Error while retrieve section by id, invalid id");
//                return nullptr;
//            }
//            return &((K *) &_data[header->e_shoff])[id];
//
//        } else {
//            auto *header = (Elf32_Ehdr *) &_data[0];
//
//            if (id > header->e_shnum) {
//                log("Error while retrieve section by id, invalid id");
//                return nullptr;
//            }
//            return &((K *) &_data[header->e_shoff])[id];
//        }
//
//        return nullptr;
//    }









/// down



//
//    void Elf::patchVerneed(int additionalEntriesCount, int newOffset, int newVerSymOffset) {
//        if (is64()) {
//            auto *dynamic = getSectionByName<Elf64_Shdr>(std::string(".dynamic"));
//            if (dynamic == nullptr) {
//                log("Could not find dynamic section!");
//                return;
//            }
//            auto *dynstr = getSectionByName<Elf64_Shdr>(".dynstr");
//            if (dynstr == nullptr) {
//                log("Could not find dynstr section!");
//                return;
//            }
//            char *strTab = reinterpret_cast<char *>(&_data[dynstr->sh_offset]);
//
//            /// strtab2
//            char *rpath = nullptr;
//            log("Searching for libraries in dynamic section");
//
//            auto *dyn = (Elf64_Dyn *) (&_data[(dynamic->sh_offset)]);
//            for (; dyn->d_tag != DT_NULL; dyn++) {
//                if (dyn->d_tag == DT_VERNEEDNUM) {
//                    if (dyn->d_un.d_val != 0) {
//                        log("Found VERNEEDNUM <%lx> <%p>", dyn->d_un.d_val, dyn->d_un.d_ptr);
//                        dyn->d_un.d_val = dyn->d_un.d_val + additionalEntriesCount;
//                        dyn->d_un.d_ptr = dyn->d_un.d_ptr + additionalEntriesCount;
//                    }
//                } else if (dyn->d_tag == DT_VERNEED) {
//                    if (dyn->d_un.d_val != 0) {
//                        log("Found VERNEED <%lx> <%p>", dyn->d_un.d_val, dyn->d_un.d_ptr);
//                        dyn->d_un.d_val = newOffset;
//                        dyn->d_un.d_ptr = newOffset;
//                    }
//                } else if (dyn->d_tag == DT_VERSYM) {
//                    log("Found DT_VERSYM <%lx> <%p>", dyn->d_un.d_val, dyn->d_un.d_ptr);
//                    //dyn->d_un.d_val = newVerSymOffset;
//                    //dyn->d_un.d_ptr = newVerSymOffset;
//
//                } else if (dyn->d_tag == DT_VERDEF) {
//                    log("Found DT_VERDEF <%lx> <%p>", dyn->d_un.d_val, dyn->d_un.d_ptr);
//                    //dyn->d_un.d_val = newVerSymOffset;
//                    //dyn->d_un.d_ptr = newVerSymOffset;
//
//                } /*else if(dyn->d_tag == DT_NEEDED) {
//                    log("Found DT_NEEDED <%lx> <%p>", dyn->d_un.d_val, dyn->d_un.d_ptr);
//                }*/
//            }
//        }
//    }
//
//    void
//    Elf::addVersionDependency(const std::string &name, const int strId, const int newDystrOffset) {
//        if (is64()) {
//            Elf64_Shdr *gnuVersionSection = getSectionByName<Elf64_Shdr>(".gnu.version_r"); //_r
//
//            Elf64_Shdr *gnuVersionStringsSection = getSectionById<Elf64_Shdr>(
//                    gnuVersionSection->sh_link);
//
//
//            char *strTab = reinterpret_cast<char *>(&_data[gnuVersionStringsSection->sh_offset]);
//
//            std::string versionStringsSectionName = getSectionName<Elf64_Shdr>(
//                    gnuVersionStringsSection);
//            log("versionStringsSectionName: <%s>", versionStringsSectionName.c_str());
//            if (versionStringsSectionName.compare(".dynstr") != 0) {
//                log("version dependency strings not in .dynstr... not supported yet");
//                return; // TODO crash?
//            }
//            //gnuVersionSection->sh_link = newDystrOffset;
//
//            char *rpath = nullptr;
//            int rel_offset = 0;
//            Elf64_Verneed *verneed = (Elf64_Verneed *) &_data[gnuVersionSection->sh_offset];
//            while (verneed != nullptr) {
//                rpath = strTab + verneed->vn_file;
//                log("Found verneed vn_file<%lx> vn_version<%lx> vn_next<%lx> vn_file<%lx> name<%s> vn_aux<%lx> rel_offset<%lx>",
//                    verneed->vn_file, verneed->vn_version, verneed->vn_next, verneed->vn_file,
//                    rpath, verneed->vn_aux,
//                    rel_offset);
//                if (verneed->vn_next == 0) {
//                    log("No more verneeds found");
//                    break;
//                }
//                rel_offset += verneed->vn_next;
//                verneed = reinterpret_cast<Elf64_Verneed *>((char *) verneed + verneed->vn_next);
//            }
//
//            // modify
//            Elf64_Verneed newVerneed;
//            newVerneed.vn_file = strId;
//            newVerneed.vn_next = 0;
//            newVerneed.vn_cnt = 1;
//            newVerneed.vn_aux = 0x10;
//            newVerneed.vn_version = 1;
//
//            int oldVersionSectionSize = gnuVersionSection->sh_size;
//
//
//            int oldSize = gnuVersionSection->sh_size;
//            int oldOff = gnuVersionSection->sh_offset;
//            int newSize = sizeof(Elf64_Verneed) + sizeof(Elf64_Vernaux);
//            int newOffset = moveSectionToEndAndResize(".gnu.version_r",
//                                                      newSize, false, false);
//
//            Elf64_Verneed *testVerneed = reinterpret_cast<Elf64_Verneed *>(&_data[newOffset]);
//
//            log("new verneed address <%p> ", testVerneed);
//            log("Add new verneed <%p> vn_file<%lx> vn_version<%lx> vn_next<%lx> name<%s> vn_aux<%lx>",
//                ((char *) testVerneed) + oldVersionSectionSize,
//                newVerneed.vn_file, newVerneed.vn_version, newVerneed.vn_next, name.c_str(),
//                newVerneed.vn_aux);
//
//            memcpy(((char *) testVerneed) + oldVersionSectionSize, &newVerneed,
//                   sizeof(Elf64_Verneed));
//            //gnuVersionSection->sh_size = gnuVersionSection->sh_size + sizeof(Elf64_Verneed); // update sh size
//            Elf64_Vernaux newVernaux;
//            newVernaux.vna_name = strId;
//            newVernaux.vna_flags = 0;
//            newVernaux.vna_hash = 0;
//            newVernaux.vna_other = 2;
//            newVernaux.vna_next = 0;
//            memcpy(((char *) testVerneed) + oldVersionSectionSize + sizeof(Elf64_Verneed),
//                   &newVernaux,
//                   sizeof(Elf64_Vernaux));
//
//            // test
//            Elf64_Shdr *newGnuVersionSection = getSectionByName<Elf64_Shdr>(".gnu.version_r"); //_r
//            newGnuVersionSection->sh_info = newGnuVersionSection->sh_info + 1;
//            verneed = (Elf64_Verneed *) &_data[newGnuVersionSection->sh_offset];
//            log("new verneed address <%p> ", verneed);
//            rel_offset = 0;
//            while (verneed != nullptr) {
//                rpath = strTab + verneed->vn_file;
//                log("AFTER MODIFY: Found verneed <%p> vn_file<%lx> vn_version<%lx> vn_next<%lx> vn_file<%lx> name<%s> vn_aux<%lx> rel_offset<%lx>",
//                    verneed,
//                    verneed->vn_file, verneed->vn_version, verneed->vn_next, verneed->vn_file,
//                    rpath, verneed->vn_aux,
//                    rel_offset);
//                Elf64_Vernaux *vernaux = (Elf64_Vernaux *) (((char *) verneed + verneed->vn_aux));
//                while (vernaux != nullptr) {
//                    log("AFTER MODIFY: Found vernaux <%p> vna_hash<%lx> vna_flags<%lx> vna_other<%lx> vna_name<%lx>",
//                        vernaux,
//                        vernaux->vna_hash, vernaux->vna_flags, vernaux->vna_other,
//                        vernaux->vna_name);
//                    if (vernaux->vna_next == 0) {
//                        break;
//                    }
//                    vernaux = reinterpret_cast<Elf64_Vernaux *>(((char *) vernaux +
//                                                                 vernaux->vna_next));
//                }
//
//                if (verneed->vn_next == 0) {
//                    log("No more verneeds found");
//                    break;
//                }
//                rel_offset += verneed->vn_next;
//                verneed = reinterpret_cast<Elf64_Verneed *>((char *) verneed + verneed->vn_next);
//            }
//            verneed->vn_next =
//                    (oldSize - rel_offset); // calculate offset to our new verneed
//            patchVerneed(1, newOffset, newDystrOffset);
//
//        }
//
//
//    }














//    void Elf::addLibraryDependency(const std::string &library) {
//        log("add library dependency <%s>", library.c_str());
//        if (is64()) {
//            // retrieve dynamic and dynstr sections
//            Elf64_Shdr *dynstrSectionAddr = getSectionByName<Elf64_Shdr>(".dynstr");
//
//            // calculate size of bytes to inject
//            int additionalDynamicLen = sizeof(Elf64_Dyn);
//            int additionalDynstrLen = library.size() + 1;// string size + \0
//
//
//            int off = moveSectionToEndAndResize(".dynamic",
//                                                additionalDynamicLen, true, false);
//            off = moveSectionToEndAndResize(".dynamic",
//                                            additionalDynamicLen, true, true);
//            // edit dynamic
//
//            Elf64_Dyn *testDyn = reinterpret_cast<Elf64_Dyn *>(&_data[off]);
//            memcpy(testDyn, dynstrSectionAddr, sizeof(Elf64_Dyn));
//            testDyn->d_un.d_ptr = dynstrSectionAddr->sh_size;//dynstrSectionAddr->sh_size
//            testDyn->d_un.d_val = dynstrSectionAddr->sh_size;//dynstrSectionAddr->sh_size
//            testDyn->d_tag = DT_NEEDED;
//
//
////            wri(newDyn.d_un.d_val, j);
//
//
//            int newOffset = moveSectionToEndAndResize(".dynstr",
//                                                      additionalDynstrLen, false, false);
//            const char *newLibName = library.c_str();
//            memcpy(&_data[newOffset + dynstrSectionAddr->sh_size], newLibName,
//                   strlen(newLibName) + 1);
//
//            addVersionDependency(library, testDyn->d_un.d_val, newOffset);
//
//            // write changes
//            _is.close(); // TODO put into function
//            //_is.open(_path, std::ifstream::in | std::ifstream::binary | std::ifstream::ate);
//            std::ofstream _os(_path);
//            _os.write(reinterpret_cast<const char *>(&_data[0]), _data.size());
//            _os.close();
//            open();
//
//        } else {
//
//        }
// }



//    void Elf::resize(uint32_t newLen) {
//        this->_data.resize(newLen);
//    }
//
//    int
//    Elf::moveSectionToEndAndResize(const std::string &section, uint32_t newAdditionalSectionLen,
//                                   bool end, bool searchPhdr) {
//        log("moveSectionToEndAndResize [-] move section <%s>", section.c_str());
//        if (is64()) {
//            Elf64_Shdr *sectionHeader = getSectionByName<Elf64_Shdr>(section);
//
//            Elf64_Off oldOffset = sectionHeader->sh_offset;
//            Elf64_Xword oldSize = sectionHeader->sh_size;
//            uint32_t newLen = oldSize + newAdditionalSectionLen;
//            Elf64_Off newOffset = _data.size();
//
//            log("moveSectionToEndAndResize [-] lib addr <%p>", &_data[0]);
//            log("moveSectionToEndAndResize [-] section addr <%p>", sectionHeader);
//            log("moveSectionToEndAndResize [-] section offset addr <%p>",
//                &sectionHeader->sh_offset);
//            log("moveSectionToEndAndResize [-] old section offset <%lx>", oldOffset);
//            log("moveSectionToEndAndResize [-] new section offset <%lx>", newOffset);
//            log("moveSectionToEndAndResize [-] old section size <%lx>", oldSize);
//            log("moveSectionToEndAndResize [-] new section size <%lx>", newLen);
//
//            int newLibSize = _data.size() + newLen;
//            log("moveSectionToEndAndResize [-] old lib size <%d>", _data.size());
//            log("moveSectionToEndAndResize [-] new lib size <%d>", newLibSize);
//            _data.resize(newLibSize);
//
//            // copy this sh
//            Elf64_Shdr newHeader;
//            memcpy(&newHeader, sectionHeader, sizeof(Elf64_Shdr));
//            // set new offset
//            newHeader.sh_offset = newOffset;
//            newHeader.sh_addr = newOffset;
//
//
//            // set new len
//            newHeader.sh_size = newLen;
//            memcpy(sectionHeader, &newHeader, sizeof(Elf64_Shdr));
//            Elf64_Shdr *sectionHeader2 = getSectionByName<Elf64_Shdr>(section);
//            log("moveSectionToEndAndResize [-] updated section offset <%p> <%lx> <%lx> <%lx>",
//                &sectionHeader2->sh_offset, sectionHeader2->sh_offset, sectionHeader->sh_offset,
//                newHeader.sh_offset);
//
//
//            // copy the section
//            if (end) {
//                memcpy(&_data[newOffset + newAdditionalSectionLen], &_data[oldOffset], oldSize);
//
//            } else {
//                memcpy(&_data[newOffset], &_data[oldOffset], oldSize);
//            }
//
//            if (searchPhdr) {
//                log("moveSectionToEndAndResize [-] let's search for the corresponding phdr");
//                auto *header = (Elf64_Ehdr *) &_data[0];
//                bool found = false;
//                for (int k = 0; k < header->e_phnum; k++) {
//                    auto phdr = &((Elf64_Phdr *) &_data[header->e_phoff])[k];
//                    log("moveSectionToEndAndResize [-] found phdr p_offset<%lx> p_type<%lx> p_vaddr<%lx>",
//                        phdr->p_offset, phdr->p_type, phdr->p_vaddr);
//                    if (phdr->p_offset == oldOffset) {
//                        log("Found phdr for dynamic section!");
//                        phdr->p_paddr = newOffset + (phdr->p_paddr - phdr->p_offset);
//                        phdr->p_vaddr = newOffset + (phdr->p_vaddr - phdr->p_offset);
//                        phdr->p_offset = newOffset;
//                        log("moveSectionToEndAndResize [-] successful moved to phdr p_offset<%lx> p_type<%lx> p_vaddr<%lx>",
//                            phdr->p_offset, phdr->p_type, phdr->p_vaddr);
//
//                        found = true;
//                        break;
//                    }
//                }
//                if (!found) {
//                    log("!!WARNING!! Could not find corresponding dynamic phdr...");
//                }
//            }
//
//            log("moveSectionToEndAndResize [-] done");
//
//            return newOffset;
//        } else {
//
//        }
//
//        return 0;
//    }
//